#!/bin/bash

set -x

# Check for OCM installation and version
if ! command -v ocm &> /dev/null; then
    echo "ERROR: ocm CLI is not installed. Please install it first."
    exit 1
fi

OCM_VERSION=$(ocm version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
REQUIRED_VERSION="0.1.73"  # minimum version for PSC support

if [ "$(printf '%s\n' "$REQUIRED_VERSION" "$OCM_VERSION" | sort -V | head -n1)" != "$REQUIRED_VERSION" ]; then
    echo "ERROR: OCM version $OCM_VERSION is too old. PSC requires at least $REQUIRED_VERSION"
    echo "Please upgrade: https://github.com/openshift-online/ocm-cli/releases"
    exit 1
fi

# Check for jq
jq > /dev/null 2>&1 || echo "Please ensure jq is installed"



# Check for OCM connectivity
ocm get /api/clusters_mgmt/v1/clusters --parameter search="name like '${cluster_name}%'" | jq -re '.items[].name' && (echo 'Cluster seems to exist... please clean it up first or select a new name.'; exit 1; )

if [[ "${gcp_authentication_type}" == "service_account" ]]; then
  # Check if the GCP SA is valid
  ## Get private key ID
  export PRIV_KEY_ID=$(cat ${gcp_sa_file_loc} | jq -r '.private_key_id')
  curl -s $(cat ${gcp_sa_file_loc} | jq -r '.client_x509_cert_url') | jq -re --arg PRIV_KEY_ID "$PRIV_KEY_ID" '.[$PRIV_KEY_ID]' || echo "Your service account specified at ${gcp_sa_file_loc} seems to be invalid or expired. Please check and try again"

  authentication_param_name="--service-account-file"
  authentication_param_value="${gcp_sa_file_loc}"
else # workload identity federation
  authentication_param_name="--wif-config"
  authentication_param_value="${wif_config_name}"
fi

# Set network configuration flags
network_flags=""
if [[ "${osd_gcp_private}" == "true" ]]; then
  network_flags="$network_flags --private"
fi

# PSC configuration - use the correct flag
psc_flags=""
if [[ "${osd_gcp_psc}" == "true" ]]; then
  psc_flags="--psc-subnet ${psc_subnet_name}"
fi

# Proxy configuration (for private VPC without NAT)
proxy_flags=""
if [[ -n "${http_proxy}" && "${http_proxy}" != "" ]]; then
  proxy_flags="$proxy_flags --http-proxy ${http_proxy}"
fi
if [[ -n "${https_proxy}" && "${https_proxy}" != "" ]]; then
  proxy_flags="$proxy_flags --https-proxy ${https_proxy}"
fi
if [[ -n "${no_proxy}" && "${no_proxy}" != "" ]]; then
  proxy_flags="$proxy_flags --no-proxy ${no_proxy}"
fi
if [[ -n "${additional_trust_bundle}" && "${additional_trust_bundle}" != "" ]]; then
  proxy_flags="$proxy_flags --additional-trust-bundle-file ${additional_trust_bundle}"
fi

# Custom domain prefix
domain_flags=""
if [[ -n "${domain_prefix}" && "${domain_prefix}" != "" ]]; then
  domain_flags="--domain-prefix ${domain_prefix}"
fi

# Compute machine type
compute_machine_type_flag=""
if [[ -n "${compute_machine_type}" && "${compute_machine_type}" != "" ]]; then
  compute_machine_type_flag="--compute-machine-type ${compute_machine_type}"
fi

# Cluster version
version_flag=""
if [[ -n "${cluster_version}" && "${cluster_version}" != "" ]]; then
  version_flag="--version ${cluster_version}"
fi

# Machine CIDR (overall IP range for cluster machines)
machine_cidr_flag=""
if [[ -n "${machine_cidr}" && "${machine_cidr}" != "" ]]; then
  machine_cidr_flag="--machine-cidr ${machine_cidr}"
fi

# Multi-AZ configuration
availability_zones_flags=""
compute_nodes_flag=""
multi_az_flag=""
if [[ -n "${gcp_availability_zones}" && "${gcp_availability_zones}" != "" ]]; then
  # OCM requires --multi-az flag when using multiple availability zones
  multi_az_flag="--multi-az"
  # OCM expects comma-separated zones as a single flag value (without quotes in the flag itself)
  availability_zones_flags="--availability-zones"
  availability_zones_value="${gcp_availability_zones}"
  
  # Count number of zones
  IFS=',' read -ra ZONES <<< "${gcp_availability_zones}"
  ZONE_COUNT=$${#ZONES[@]}
  
  # Determine compute nodes count
  if [ -z "${compute_nodes_count}" ] || [ "${compute_nodes_count}" = "" ]; then
    # Default: minimum for multi-AZ CCS (1 per zone)
    COMPUTE_NODES=$((ZONE_COUNT * 1))
  else
    COMPUTE_NODES="${compute_nodes_count}"
    # Validate it's a multiple of zone count
    REMAINDER=$((COMPUTE_NODES % ZONE_COUNT))
    if [ $REMAINDER -ne 0 ]; then
      echo "ERROR: compute_nodes_count ($COMPUTE_NODES) must be a multiple of zone count ($ZONE_COUNT)"
      exit 1
    fi
  fi
  compute_nodes_flag="--compute-nodes $COMPUTE_NODES"
else
  availability_zones_value=""
  # Single-AZ: use specified count or omit flag (OCM will use default minimum)
  if [ -n "${compute_nodes_count}" ] && [ "${compute_nodes_count}" != "" ]; then
    compute_nodes_flag="--compute-nodes ${compute_nodes_count}"
  fi
fi

# Create the cluster
# Redirect debug output to stderr to avoid buffering issues with Terraform shell provider
if [[ -n "$availability_zones_value" ]]; then
  # Multi-AZ cluster creation
  ocm create cluster ${cluster_name} --provider gcp \
                  --vpc-name ${vpc_name} \
                  --region ${gcp_region} \
                  --control-plane-subnet ${control_plane_subnet} \
                  --compute-subnet ${compute_subnet} \
                  "$authentication_param_name" "$authentication_param_value" \
                  $network_flags \
                  $psc_flags \
                  $proxy_flags \
                  $domain_flags \
                  $version_flag \
                  $machine_cidr_flag \
                  $multi_az_flag \
                  $availability_zones_flags "$availability_zones_value" \
                  $compute_nodes_flag \
                  $compute_machine_type_flag \
                  --ccs 2>&1
else
  # Single-AZ cluster creation
  ocm create cluster ${cluster_name} --provider gcp \
                  --vpc-name ${vpc_name} \
                  --region ${gcp_region} \
                  --control-plane-subnet ${control_plane_subnet} \
                  --compute-subnet ${compute_subnet} \
                  "$authentication_param_name" "$authentication_param_value" \
                  $network_flags \
                  $psc_flags \
                  $proxy_flags \
                  $domain_flags \
                  $version_flag \
                  $machine_cidr_flag \
                  $compute_machine_type_flag \
                  --ccs 2>&1
fi



echo ""
echo "======================================"
echo "Cluster creation initiated!"
echo "This typically takes 30-45 minutes"
echo "======================================"

# Function to get cluster ID using OCM API with server-side filtering
# This is much faster than 'ocm list clusters | grep' which downloads all clusters
get_cluster_id() {
    ocm get /api/clusters_mgmt/v1/clusters --parameter search="name = '${cluster_name}'" 2>/dev/null | jq -r '.items[0].id // empty'
}

# Get cluster ID using server-side search (fast, doesn't hang)
sleep 5  # Give OCM a moment to register the cluster
CLUSTER_ID=$(get_cluster_id)

if [ -z "$CLUSTER_ID" ]; then
    echo "WARNING: Could not immediately find cluster ID. Waiting..."
    sleep 30
    CLUSTER_ID=$(get_cluster_id)
fi

if [ -z "$CLUSTER_ID" ]; then
    echo "ERROR: Could not find cluster ${cluster_name}"
    exit 1
fi

echo "Cluster ID: $CLUSTER_ID"
echo "Monitoring installation progress..."

# Monitor installation using direct API calls (faster than ocm list)
MAX_ATTEMPTS=45  # 45 * 2 minutes = 90 minutes
ATTEMPT=0

while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
    # Use single API call to get cluster details
    CLUSTER_INFO=$(ocm get /api/clusters_mgmt/v1/clusters/$CLUSTER_ID 2>/dev/null)
    STATE=$(echo "$CLUSTER_INFO" | jq -r '.state')
    PROGRESS=$(echo "$CLUSTER_INFO" | jq -r '.status.description // "Installing"')
    
    echo "[$(date '+%H:%M:%S')] State: $STATE | Progress: $PROGRESS"
    
    if [ "$STATE" == "ready" ]; then
        echo ""
        echo "======================================"
        echo "Cluster ${cluster_name} is READY!"
        echo "======================================"
        API_URL=$(echo "$CLUSTER_INFO" | jq -r '.api.url')
        CONSOLE_URL=$(echo "$CLUSTER_INFO" | jq -r '.console.url')
        echo "API URL: $API_URL"
        echo "Console URL: $CONSOLE_URL"
        echo ""
        echo "For private clusters: Configure IdP at https://console.redhat.com before accessing"
        echo "Then access via bastion: gcloud compute ssh ${cluster_name}-bastion-vm --zone=${gcp_zone}"
        break
    elif [ "$STATE" == "error" ]; then
        echo "Cluster installation failed!"
        ERROR_MSG=$(echo "$CLUSTER_INFO" | jq -r '.status.provision_error_message // .status.description')
        echo "Error: $ERROR_MSG"
        exit 1
    fi
    
    sleep 120  # 2 minutes
    ATTEMPT=$((ATTEMPT+1))
done

if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
    echo "Timeout after 90 minutes. Check status at https://console.redhat.com"
    exit 1
fi

# Output cluster ID as JSON for Terraform to capture
echo ""
echo "TERRAFORM_OUTPUT_START"
jq -n --arg cluster_id "$CLUSTER_ID" --arg cluster_name "${cluster_name}" '{cluster_id: $cluster_id, cluster_name: $cluster_name}'
echo "TERRAFORM_OUTPUT_END"